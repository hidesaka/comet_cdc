// Generated by CoffeeScript 1.9.3
(function() {
  var DialGauge, Endplate, LayerSelection, Load, Progress, S3, Tension, TensionBar, TensionHistogram, append_svg, diam, get_xypos, h, height, holes, i, j, k, l, len, makeBarChart, makeLine, makeScatterPlot, makeStatBox, makeTooltip, make_frame, margin, num, numTotalWires, numWires, ref, w, width;

  diam = 180;

  w = 650;

  h = 650;

  margin = {
    top: 20,
    right: 150,
    bottom: 50,
    left: 80
  };

  width = w - margin.left - margin.right;

  height = 300 - margin.top - margin.bottom;

  numWires = [396, 396, 396, 408, 408, 420, 420, 432, 432, 444, 444, 456, 456, 468, 468, 480, 480, 492, 492, 504, 504, 516, 516, 528, 528, 540, 540, 552, 552, 564, 564, 576, 576, 588, 588, 600, 600, 612, 612];

  numTotalWires = _.reduce(numWires, function(memo, num) {
    return memo + num;
  });

  get_xypos = function(layerid, wireid, num_wires) {
    var deg, r, rad, x, y;
    r = 50 + (layerid - 1);
    deg = (wireid - 1) / num_wires * 360;
    rad = deg / 180.0 * Math.PI;
    x = r * Math.cos(rad);
    y = r * Math.sin(rad);
    return {
      x: x,
      y: y
    };
  };

  holes = [];

  for (i = k = 0, len = numWires.length; k < len; i = ++k) {
    num = numWires[i];
    for (j = l = 0, ref = num; 0 <= ref ? l <= ref : l >= ref; j = 0 <= ref ? ++l : --l) {
      holes.push(get_xypos(i + 1, j + 1, numWires[i]));
    }
  }

  append_svg = function(id) {
    return d3.select(id).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + ", " + margin.top + ")");
  };

  make_frame = function(svg, xtitle, ytitle, xdomain, ydomain, options) {
    var tick_label_dx, tick_label_dy, tick_label_rotate, xAxis, xScale, xx, yAxis, yScale;
    svg.selectAll("g").remove();
    xScale = "";
    if (options.xaxis_type === "roundBands") {
      xScale = d3.scale.ordinal().domain(xdomain).rangeRoundBands([0, width]);
    } else if (options.xaxis_type === "time") {
      xScale = d3.time.scale().domain(xdomain).range([0, width]).nice();
    } else {
      xScale = d3.scale.linear().domain(xdomain).range([0, width]);
    }
    yScale = d3.scale.linear().domain(ydomain).range([height, 0]).nice();
    if (!options.no_axis) {
      tick_label_dx = 0;
      tick_label_dy = 10;
      tick_label_rotate = "0";
      xAxis = d3.svg.axis().scale(xScale).orient("bottom");
      if (options.xaxis_tickValues != null) {
        xAxis.tickValues(options.xaxis_tickValues);
      }
      if (options.xaxis_type === "time") {
        xAxis.ticks(5).tickFormat(d3.time.format('%b %d'));
        tick_label_rotate = "-65";
        tick_label_dx = -30;
        tick_label_dy = -1;
      }
      yAxis = d3.svg.axis().scale(yScale).orient("left");
      xx = svg.append("g").attr("class", "axis").attr("transform", "translate(0," + height + ")").call(xAxis);
      xx.selectAll("text").attr("transform", "rotate(" + tick_label_rotate + ")").attr("text-anchor", "start").attr("dx", tick_label_dx).attr("dy", tick_label_dy);
      xx.append("text").attr("x", width + 8).attr("y", 10).attr("text-anchor", "start").text(xtitle);
    }
    svg.append("g").attr("class", "axis").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", -55).attr("dy", ".71em").style("text-anchor", "end").text(ytitle);
    return {
      "svg": svg,
      "xScale": xScale,
      "yScale": yScale
    };
  };

  makeBarChart = function(frame, data, xdata, ydata, fillColor, tooltip) {
    frame.svg.selectAll("rect").remove();
    frame.svg.selectAll(".bar").data(data).enter().append("rect").attr("fill", fillColor).attr("x", function(d) {
      return frame.xScale(d[xdata]);
    }).attr("width", frame.xScale.rangeBand() * 0.97).attr("y", height).attr("height", 0).transition().duration(1000).attr("y", function(d, i) {
      return frame.yScale(d[ydata]);
    }).attr("height", function(d) {
      return height - frame.yScale(d[ydata]);
    });
    if (tooltip) {
      return makeTooltip(frame, "rect", data, xdata, ydata, tooltip.label);
    }
  };

  makeScatterPlot = function(frame, data, xdata, ydata, options, legend_entry, tooltip) {
    var legend, line;
    if (options.line_stroke) {
      line = d3.svg.line().x(function(d) {
        return frame.xScale(d[xdata]);
      }).y(function(d) {
        return frame.yScale(d[ydata]);
      });
      frame.svg.append("path").attr("stroke", options.line_stroke).attr("fill", "none").attr("d", line(data));
    }
    frame.svg.selectAll("circle").remove();
    if (legend_entry.length !== 0) {
      legend = frame.svg.append("g").attr("x", width - 65).attr("y", 25).attr("height", 100).attr("width", 100).selectAll("text").data(legend_entry).enter().append("text").attr("x", w - 180).attr("y", function(d) {
        return d.ypos;
      }).attr("height", 30).attr("width", 100).style("fill", function(d) {
        return d.stroke;
      }).text(function(d) {
        return d.label;
      });
      frame.svg.append("g").attr("x", width - 75).attr("y", 25).attr("height", 100).attr("width", 100).selectAll(".circle").data(legend_entry).enter().append("circle").attr("cx", w - 190).attr("cy", function(d) {
        return d.ypos - 4;
      }).attr("r", 3).attr("fill", function(d) {
        return d.fill;
      }).attr("stroke", function(d) {
        return d.stroke;
      }).attr("stroke-width", "1px");
    }
    frame.svg.selectAll(".circle").data(data).enter().append("g").attr("class", "dot").append("circle").attr("cx", function(d, i) {
      return frame.xScale(d[xdata]);
    }).attr("cy", function(d, i) {
      return frame.yScale(d[ydata]);
    }).attr("r", 3).attr("fill", options.fill).attr("stroke", options.stroke).attr("stroke-width", options.stroke_width);
    if (tooltip) {
      return makeTooltip(frame, ".dot circle", data, xdata, ydata, tooltip.label);
    }
  };

  makeLine = function(frame, class_name, points) {
    var line;
    line = d3.svg.line().x(function(d) {
      return frame.xScale(d.x);
    }).y(function(d) {
      return frame.yScale(d.y);
    });
    return frame.svg.append("path").datum(points).attr("class", class_name).attr("d", line);
  };

  makeStatBox = function(frame, x, y, text) {
    frame.svg.select("text").remove();
    return frame.svg.append("text").attr("x", x).attr("y", y).text(text);
  };

  makeTooltip = function(frame, class_name, data, xdata, ydata, labels) {
    var focus, get_msg;
    focus = frame.svg.append("g").attr("class", "focus").style("display", "none");
    focus.append("rect").attr("opacity", "0.6").attr("x", 9).attr("y", 9).attr("rx", 2).attr("ry", 2).attr("width", 30).attr("height", function() {
      if (labels.length === 1) {
        return 20;
      } else {
        return labels.length * 17;
      }
    });
    focus.selectAll("text").data(labels).enter().append("text").attr("x", 14).attr("y", 12).attr("font-family", "Inconsolata").attr("font-size", "10px").attr("fill", "white");
    get_msg = function(d, label, i) {
      var ent, len1, m, msg, ref1;
      msg = label.prefix || '';
      ref1 = label.data;
      for (i = m = 0, len1 = ref1.length; m < len1; i = ++m) {
        ent = ref1[i];
        if (typeof ent === 'function') {
          msg += ent(d);
        } else {
          msg += d[ent];
        }
        if (i < label.data.length - 1) {
          msg += label.separator || '';
        }
      }
      return msg += label.postfix || '';
    };
    return frame.svg.selectAll(class_name).data(data).on("mouseover", function() {
      return focus.style("display", null);
    }).on("mouseout", function() {
      return focus.style("display", "none");
    }).on("mousemove", function(d) {
      var xval, yval;
      xval = typeof xdata === 'function' ? xdata(d) : d[xdata];
      yval = typeof ydata === 'function' ? ydata(d) : d[ydata];
      focus.select("rect").attr("transform", "translate(" + frame.xScale(xval) + "," + (frame.yScale(yval) - 10) + ")");
      focus.select("rect").attr("width", function() {
        var line, max_len;
        line = [];
        focus.selectAll("text").each(function(label, i) {
          return line.push(get_msg(d, label, i));
        });
        max_len = d3.max(line, function(d) {
          return d.length;
        });
        return 14 + max_len * 4.7;
      });
      focus.selectAll("text").attr("transform", function(_, i) {
        return "translate(" + (frame.xScale(xval)) + ", " + (frame.yScale(yval) + i * 15) + ")";
      });
      return focus.selectAll("text").text(function(label, i) {
        return get_msg(d, label, i);
      });
    });
  };

  S3 = (function() {
    function S3() {
      this.awsRegion = "us-east-1";
      this.cognitoParams = {
        IdentityPoolId: "us-east-1:435dfdc9-d483-4f5e-8f8b-27e3569ad9af"
      };
      this.s3BucketName = "comet-cdc";
      this.s3RegionName = "ap-northeast-1";
      AWS.config.region = this.awsRegion;
      AWS.config.credentials = new AWS.CognitoIdentityCredentials(this.cognitoParams);
      AWS.config.credentials.get(function(err) {
        if (!err) {
          return console.log("Cognito Identity Id: " + AWS.config.credentials.identityId);
        }
      });
      this.s3 = new AWS.S3({
        params: {
          Bucket: this.s3BucketName,
          Region: this.s3RegionName
        }
      });
      console.log("=== s3 ====");
      console.log(this.s3);
      console.log("===========");
    }

    S3.prototype.getObject = function(name, callback) {
      return this.s3.listObjects((function(_this) {
        return function(err, data) {
          var len1, m, obj, ref1, results;
          ref1 = data.Contents;
          results = [];
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            obj = ref1[m];
            if (obj.Key === name) {
              results.push(callback(_this.s3.getSignedUrl('getObject', {
                Bucket: _this.s3BucketName,
                Key: obj.Key
              })));
            }
          }
          return results;
        };
      })(this));
    };

    return S3;

  })();

  DialGauge = (function() {
    function DialGauge() {}

    DialGauge.prototype.read_csv = function(csv) {
      var d1, d2, d3, d4, data, date, ent, len1, m, temp, time, utime, v1, v11, v12, v1_start, v2, v21, v22, v2_start, v3, v31, v32, v3_start, v4, v41, v42, v4_start;
      j = 0;
      data = [];
      for (m = 0, len1 = csv.length; m < len1; m++) {
        ent = csv[m];
        v11 = ent["10deg_1mm"];
        v12 = ent["10deg_10um"];
        v21 = ent["90deg_1mm"];
        v22 = ent["90deg_10um"];
        v31 = ent["180deg_1mm"];
        v32 = ent["180deg_10um"];
        v41 = ent["270deg_1mm"];
        v42 = ent["270deg_10um"];
        if (!v11 || !v21 || !v31 || !v41) {
          continue;
        }
        if (!v12 || !v22 || !v32 || !v42) {
          continue;
        }
        v1 = (parseFloat(v11) + parseFloat(v12)) * 1000;
        v2 = (parseFloat(v21) + parseFloat(v22)) * 1000;
        v3 = (parseFloat(v31) + parseFloat(v32)) * 1000;
        v4 = (parseFloat(v41) + parseFloat(v42)) * 1000;
        if (j === 0) {
          v1_start = v1;
          v2_start = v2;
          v3_start = v3;
          v4_start = v4;
        }
        d1 = v1 - v1_start;
        d2 = v2 - v2_start;
        d3 = v3 - v3_start;
        d4 = v4 - v4_start;
        utime = Date.parse(ent["Date"] + " " + ent["Time"]);
        date = ent["Date"];
        time = ent["Time"];
        temp = ent["Temp"];
        data[j++] = {
          "utime": utime,
          "date": date,
          "time": time,
          "temp": temp,
          "location": "at10deg",
          "disp_um": parseFloat(d1)
        };
        data[j++] = {
          "utime": utime,
          "date": date,
          "time": time,
          "temp": temp,
          "location": "at90deg",
          "disp_um": parseFloat(d2)
        };
        data[j++] = {
          "utime": utime,
          "date": date,
          "time": time,
          "temp": temp,
          "location": "at180deg",
          "disp_um": parseFloat(d3)
        };
        data[j++] = {
          "utime": utime,
          "date": date,
          "time": time,
          "temp": temp,
          "location": "at270deg",
          "disp_um": parseFloat(d4)
        };
      }
      return data;
    };

    DialGauge.prototype.plot = function(csv) {
      var fill_gauge, frame_gauge, gauge_data, stroke_gauge, svg_gauge, xdomain_gauge, ydomain_gauge;
      gauge_data = this.read_csv(csv);
      xdomain_gauge = d3.extent(gauge_data, function(d) {
        return d.utime;
      });
      ydomain_gauge = d3.extent(gauge_data, function(d) {
        return d.disp_um;
      });
      svg_gauge = append_svg("#menu_gauge");
      frame_gauge = make_frame(svg_gauge, "date", "displacement (um)", xdomain_gauge, ydomain_gauge, {
        xaxis_type: "time"
      });
      stroke_gauge = {
        at10deg: "#ed5454",
        at90deg: "#3874e3",
        at180deg: "#228b22",
        at270deg: "#ffa500"
      };
      fill_gauge = {
        at10deg: "#f8d7d7",
        at90deg: "#bdd0f4",
        at180deg: "#9acd32",
        at270deg: "#ffead6"
      };
      return makeScatterPlot(frame_gauge, gauge_data, "utime", "disp_um", {
        fill: function(d) {
          return fill_gauge[d.location];
        },
        stroke: function(d) {
          return stroke_gauge[d.location];
        },
        stroke_width: "1px"
      }, [
        {
          label: "10deg",
          stroke: '#ed5454',
          fill: "#f8d7d7",
          ypos: "66",
          label: "90deg",
          stroke: '#3874e3',
          fill: "#bdd0f4",
          ypos: "83",
          label: "180deg",
          stroke: '#228b22',
          fill: "#9acd32",
          ypos: "100",
          label: "270deg",
          stroke: '#ffa500',
          fill: "#ffead6",
          ypos: "117"
        }
      ], {
        label: [
          {
            data: [
              "date", "time", function(d) {
                return d.disp_um.toFixed(0);
              }
            ],
            separator: ' ',
            postfix: ' um'
          }
        ]
      });
    };

    return DialGauge;

  })();

  TensionBar = (function() {
    function TensionBar() {}

    TensionBar.read_csv = function(csv) {
      var d1, d2, data, ent, len1, m, tension_kg, utime;
      data = [];
      for (m = 0, len1 = csv.length; m < len1; m++) {
        ent = csv[m];
        d1 = ent["Date"];
        d2 = ent["Tension_kg"];
        if (_.isEmpty(d1) || _.isEmpty(d2)) {
          continue;
        }
        utime = Date.parse(d1);
        tension_kg = parseFloat(d2);
        data.push({
          utime: utime,
          tension_kg: tension_kg
        });
      }
      return data;
    };

    TensionBar.plot = function(csv, dailies) {
      var bar, bar_data, daily, frame_all, frame_bar, jlast, len1, len2, m, n, svg_all, svg_bar, ydomain_all, ydomain_bar;
      bar_data = TensionBar.read_csv(csv);
      for (i = m = 0, len1 = dailies.length; m < len1; i = ++m) {
        daily = dailies[i];
        jlast = 0;
        for (j = n = 0, len2 = bar_data.length; n < len2; j = ++n) {
          bar = bar_data[j];
          jlast = j(-1);
          if (bar.utime > daily.utime) {
            break;
          }
        }
        daily.bar_tension_kg = bar_data[jlast].tension_kg;
        daily.all_tension_kg = daily.wire_tension_kg + bar_data[jlast].tension_kg;
      }
      ydomain_all = [
        0.9 * d3.min(dailies, function(d) {
          return d.all_tension_kg;
        }), 1.1 * d3.max(dailies, function(d) {
          return d.all_tension_kg;
        })
      ];
      svg_all = append_svg("#menu_load_all");
      frame_all = make_frame(svg_all, "date", "total loading (kg)", xdomain, ydomain_all, {
        xaxis_type: "time"
      });
      makeScatterPlot(frame_all, dailies, "utime", "all_tension_kg", {
        fill: "#9966ff",
        stroke: "#6633cc",
        stroke_width: "1px",
        line_stroke: "#6633cc"
      }, [], {
        label: [
          {
            data: [
              labelA, (function(d) {
                return (d.all_tension_kg.toFixed(1)) + " kg";
              })
            ],
            separator: ' '
          }
        ]
      });
      ydomain_bar = [
        0.9 * d3.min(dailies, (function(d) {
          return d.bar_tension_kg;
        })), 1.1 * d3.max(dailies, (function(d) {
          return d.bar_tension_kg;
        }))
      ];
      svg_bar = append_svg("#menu_load_bar");
      frame_bar = make_frame(svg_bar, "date", "loading of tension bars (kg)", xdomain, ydomain_bar, {
        xaxis_type: "time"
      });
      return makeScatterPlot(frame_bar, dailies, "utime", "bar_tension_kg", {
        fill: "#0081B8",
        stroke: "blue",
        stroke_width: "1px",
        line_stroke: "blue"
      }, [], {
        label: [
          {
            data: [
              labelA, (function(d) {
                return (d.bar_tension_kg.toFixed(1)) + " kg";
              })
            ],
            separator: ' '
          }
        ]
      });
    };

    return TensionBar;

  })();

  Progress = (function() {
    function Progress() {}

    Progress.plot = function(dailies) {
      var d, frame_progress_ave, frame_progress_bad, frame_progress_day, frame_progress_sum, svg_progress_ave, svg_progress_bad, svg_progress_day, svg_progress_sum, xdomain, ydomain_ave, ydomain_bad, ydomain_day, ydomain_sum;
      xdomain = (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = dailies.length; m < len1; m++) {
          d = dailies[m];
          results.push(d.days);
        }
        return results;
      })();
      ydomain_sum = [
        0, d3.max(dailies, function(d) {
          return d.num_sum;
        })
      ];
      ydomain_day = [
        0, d3.max(dailies, function(d) {
          return d.num_day;
        })
      ];
      ydomain_ave = [
        0, d3.max(dailies, function(d) {
          return d.num_ave;
        })
      ];
      ydomain_bad = [
        0, d3.max(dailies, function(d) {
          return d.num_bad;
        })
      ];
      svg_progress_sum = append_svg("#menu_progress #progress_sum");
      svg_progress_day = append_svg("#menu_progress #progress_day");
      svg_progress_ave = append_svg("#menu_progress #progress_ave");
      svg_progress_bad = append_svg("#menu_progress #bad_wires");
      frame_progress_sum = make_frame(svg_progress_sum, "days", "total # of stringed wires", xdomain, ydomain_sum, {
        xaxis_type: "roundBands"
      });
      frame_progress_day = make_frame(svg_progress_day, "days", "# of stringed wires", xdomain, ydomain_day, {
        xaxis_type: "roundBands"
      });
      frame_progress_ave = make_frame(svg_progress_ave, "days", "ave # of stringed wires", xdomain, ydomain_ave, {
        xaxis_type: "roundBands"
      });
      frame_progress_bad = make_frame(svg_progress_bad, "days", "# of wires to be re-stringed", xdomain, ydomain_bad, {
        xaxis_type: "roundBands"
      });
      $("#last_day").html("Finished on " + new Date(_.last(dailies).last_utime).toLocaleDateString("ja-JP"));
      makeBarChart(frame_progress_sum, dailies, "days", "num_sum", "#D70071", {
        label: [
          {
            data: ["num_sum"]
          }
        ]
      });
      makeBarChart(frame_progress_ave, dailies, "days", "num_ave", "#91D48C", {
        label: [
          {
            data: [
              function(d) {
                return d.num_ave.toFixed(1);
              }
            ]
          }
        ]
      });
      makeBarChart(frame_progress_day, dailies, "days", "num_day", "steelblue", {
        label: [
          {
            data: ["num_day"]
          }
        ]
      });
      return makeBarChart(frame_progress_bad, dailies, "days", "num_bad", "#6521A0", {
        label: [
          {
            data: ["num_bad"]
          }
        ]
      });
    };

    Progress.plotLayerDays = function(data) {
      var d, frame, layerData, layerNumbers, mydata, svg, x, xaxis_tickValues, xdomain, xmax, xmin, ydomain;
      layerData = _.groupBy(data, function(d) {
        return parseInt(d.layerID);
      });
      console.log(layerData);
      layerNumbers = _.keys(layerData);
      xmin = _.min(layerNumbers, _.identity);
      xmax = _.max(layerNumbers, _.identity);
      xmin = parseInt(xmin);
      xmax = parseInt(xmax);
      mydata = (function() {
        var m, results;
        results = [];
        for (d = m = 1; m <= 40; d = ++m) {
          results.push({
            layerID: d,
            num_days: 0
          });
        }
        return results;
      })();
      _.each(layerData, function(v, layerID) {
        var days, num_days;
        days = _.groupBy(v, function(d2) {
          return d3.date;
        });
        num_days = _.keys(days).length;
        mydata[layerID - 1].layerID = layerID;
        return mydata[layerID - 1].num_days = num_days;
      });
      svg = append_svg("#menu_progress #layer_days");
      xdomain = (function() {
        var m, results;
        results = [];
        for (x = m = 0; m <= 40; x = ++m) {
          results.push(x);
        }
        return results;
      })();
      ydomain = [0, 10];
      xaxis_tickValues = (function() {
        var m, results;
        results = [];
        for (x = m = 0; m <= 40; x = m += 5) {
          results.push(x);
        }
        return results;
      })();
      frame = make_frame(svg, "layer_id", "days", xdomain, ydomain, {
        xaxis_type: "roundBands",
        xaxis_tickValues: xaxis_tickValues
      });
      return makeBarChart(frame, mydata, "layerID", "num_days", "#A8BE62", {
        label: [
          {
            data: ["layerID"],
            prefix: 'layer_id '
          }, {
            data: ["num_days"],
            postfix: ' days'
          }
        ]
      });
    };

    return Progress;

  })();

  Load = (function() {
    function Load() {}

    Load.plot = function(dailies) {
      var frame_wire, labelA, svg_wire, xdomain, ydomain_wire;
      xdomain = d3.extent(dailies, function(d) {
        return d.utime;
      });
      labelA = (function(d) {
        return d.date;
      });
      ydomain_wire = [0, dailies[dailies.length - 1].wire_tension_kg];
      svg_wire = append_svg("#menu_load_wire");
      frame_wire = make_frame(svg_wire, "date", "loading of wires (kg)", xdomain, ydomain_wire, {
        xaxis_type: "time"
      });
      return makeScatterPlot(frame_wire, dailies, "utime", "wire_tension_kg", {
        stroke: "#ff1493",
        fill: "#ff69b4",
        stroke_width: "1px",
        line_stroke: "#ff1493"
      }, [], {
        label: [
          {
            data: [
              labelA, function(d) {
                return "" + (d.wire_tension_kg.toFixed(1)(kg));
              }
            ],
            separator: ' '
          }
        ]
      });
    };

    return Load;

  })();

  Endplate = (function() {
    function Endplate() {}

    Endplate.plot = function(data, current) {
      var svg;
      svg = d3.select("#menu_status #status").append("svg").attr({
        width: w,
        height: h
      });
      svg.selectAll("circle").data(holes).enter().append("circle").attr("cx", (function(d) {
        return d.x / diam * w * 0.9 + w / 2.0;
      })).attr("cy", (function(d) {
        return -d.y / diam * h * 0.9 + h / 2.0;
      })).attr("r", 0.5).attr("flll", "gray");
      return svg.selectAll("circle.hoge").data(data).enter().append("circle").attr("cx", function(d) {
        return +get_xypos(d.layerID, d.wireID, numWires[d.layerID - 1])["x"] / diam * w * 0.9 + w / 2;
      }).attr("cy", function(d) {
        return -get_xypos(d.layerID, d.wireID, numWires[d.layerID - 1])["y"] / diam * h * 0.9 + h / 2;
      }).attr("r", function(d) {
        return 0;
      }).transition().delay(function(d, i) {
        return (1000 / data.length) * i;
      }).duration(3000).attr("r", function(d) {
        return 1.5;
      }).attr("stroke", function(d) {
        var base;
        return typeof (base = d.tbase === "50") === "function" ? base({
          "#f8d7d7": "#bdd0f4"
        }) : void 0;
      }).attr("fill", function(d) {
        if (d.tBase === "50") {
          return "#ed5454";
        } else {
          return "#3874e3";
        }
      }).attr("stroke_width", "1px").each("end", function(current) {
        var r2, r3, r4, texts;
        r2 = parseFloat(current.num_sum / numTotalWires * 100).toFixed(0);
        r3 = parseFloat(current.num_sense / 4986 * 100).toFixed(0);
        r4 = parseFloat(current.num_field / 14562 * 100).toFixed(0);
        texts = ["Days: " + current.days + " (" + current.date + ")", "Wire:  " + r2 + "% (" + current.num_sum + "/" + numTotalWires + ")", "Sense: " + r3 + "% (" + current.num_sense + "/4986)", "Field: " + r4 + "% (" + current.num_field + "/14562)"];
        return svg.selectAll("text").data(texts).enter().append('text').text(function(txt) {
          return txt;
        }).attr("x", function(_, i) {
          return w * 1.1 / 3.0;
        }).attr("y", function(_, i) {
          return h / 2.5 + (i + 1.0) * 25;
        }).attr("font-family", "HelveticaNeue-Light").attr("font-style", "italic").attr("font-size", function(_, i) {
          if (i === 0) {
            return "20px";
          } else {
            return "20px";
          }
        }).attr("text-anchor", function(_, i) {
          if (i === 0) {
            return "start";
          } else {
            return "start";
          }
        }).attr("fill", "none").transition().duration(1000).ease("linear").attr("fill", function(_, i) {
          if (i === 2) {
            return "#ed5454";
          } else if (i === 3) {
            return "#3874e3";
          } else {
            return "black";
          }
        });
      });
    };

    return Endplate;

  })();

  LayerSelection = (function() {
    function LayerSelection() {}

    LayerSelection.plot = function(data) {
      var labels, layer_selection, p, texts;
      this.layerCheckList = (function() {
        var m, results;
        results = [];
        for (i = m = 0; m <= 39; i = ++m) {
          results.push(true);
        }
        return results;
      })();
      layer_selection = (function() {
        var m, results;
        results = [];
        for (i = m = 0; m <= 40; i = ++m) {
          results.push({
            layerid: i
          });
        }
        return results;
      })();
      labels = d3.select("#menu_tension").append("div").html("LayerID").attr("id", "layer_selection").selectAll(".test").data(layer_selection).enter().append("label").attr("class", "label_id_layers").text(function(d) {
        return d.layerid;
      }).insert("input").attr("type", "checkbox").property("checked", true).attr("id", function(d) {
        return "id_layer_" + d.layerid;
      }).attr("value", function(d) {
        return d.layerid;
      }).on("click", function(d) {
        var chk, msg;
        chk = d3.select(this).property("checked");
        msg = "layer " + d.layerid + " -> " + chk;
        this.layerCheckList[d.layerid - 1] = chk;
        Tension.plot(data, this.layerCheckList);
        TensionHistogram.plot(data, "sense");
        return TensionHistogram.plot(data, "field");
      });
      p = d3.select("#menu_tension").append("p").attr("id", "layer_selection");
      texts = ["checkall", "uncheckall"];
      p.insert("select").attr("id", "layer_selection2").selectAll(".dummy").data(texts).enter().append("option").attr("value", function(d) {
        return d;
      }).append("text").text(function(d) {
        return d;
      });
      return d3.select("#layer_selection2").on("change", function(d) {
        var chk, val;
        val = d3.select(this).property("value");
        chk = val === "checkall" ? true : false;
        labels.property("checked", chk);
        this.layerCheckList = (function() {
          var m, results;
          results = [];
          for (i = m = 0; m < 39; i = ++m) {
            results.push(chk);
          }
          return results;
        })();
        Tension.plot(data, this.layerCheckList);
        TensionHistogram.plot(data, "sense");
        return TensionHistogram.plot(data, "field");
      });
    };

    return LayerSelection;

  })();

  Tension = (function() {
    function Tension(data) {
      var frame_tension, svg_tension, xdomain_tension, ydomain_tension;
      xdomain_tension = [
        0, d3.max(data, function(d) {
          return d.wireID;
        })
      ];
      ydomain_tension = [
        0, d3.max(data, function(d) {
          return d.tens;
        })
      ];
      svg_tension = append_svg("#menu_tension");
      frame_tension = make_frame(svg_tension, "wire_id", "tension (g)", xdomain_tension, ydomain_tension, {
        xaxis_type: "linear"
      });
      LayerSelection.plot(data);
    }

    Tension.plot = function(data, layerCheckList) {
      var data_select, xmax, xmin;
      xmin = d3.min(data, function(d) {
        return d.wireID;
      });
      xmax = d3.max(data, function(d) {
        return d.wireID;
      });
      makeLine(frame_tension, "tension_limit_sense", [
        {
          x: xmin,
          y: 45
        }, {
          x: xmax,
          y: 45
        }
      ]);
      makeLine(frame_tension, "tension_limit_sense", [
        {
          x: xmin,
          y: 55
        }, {
          x: xmax,
          y: 55
        }
      ]);
      makeLine(frame_tension, "tension_limit_field", [
        {
          x: xmin,
          y: 72
        }, {
          x: xmax,
          y: 72
        }
      ]);
      makeLine(frame_tension, "tension_limit_field", [
        {
          x: xmin,
          y: 88
        }, {
          x: xmax,
          y: 88
        }
      ]);
      data_select = _.filter(data, function(d) {
        return layerCheckList[d.layerID - 1];
      });
      return makeScatterPlot(frame_tension, data_select, "wireID", "tens", {
        stroke: function(d) {
          if (d.tBase === 80) {
            return "#3874e3";
          } else {
            return "#ed5454";
          }
        },
        fill: function(d) {
          if (d.tBase === 80) {
            return "#bdd0f4";
          } else {
            return "#f8d7d7";
          }
        },
        stroke_width: function(d) {
          if (d.tens < d.tBase * 0.9 || d.tens > d.tBase * 1.1) {
            return "1px";
          } else {
            return "0px";
          }
        }
      }, [
        {
          label: "sense",
          stroke: "#ed5454",
          fill: "#f8d7d7",
          ypos: "15"
        }, {
          label: "field",
          stroke: "#3874e3",
          fill: "#bdd0f4",
          ypos: "30"
        }
      ], {
        label: [
          {
            data: ["date"]
          }, {
            data: ["layerID", "wireID"],
            separator: '-'
          }, {
            data: ["tens"],
            postfix: ' g'
          }
        ]
      });
    };

    return Tension;

  })();

  TensionHistogram = (function() {
    function TensionHistogram() {}

    TensionHistogram.prototype.constuctor = function() {
      this.svg_tension_hist = {};
      this.frame_tension_hist = {};
      return this.first_call_hist = {
        "sense": true,
        "field": true
      };
    };

    TensionHistogram.plot = function(data, sense_or_field) {
      var bindatum, data_select, entries, frac_rms, nx, tension_mean, tension_rms, tick, tick_list, x, xaxis_tickValues, xdomain, xmax, xmin, xstep, ydomain;
      nx = 20;
      if (sense_or_field === "sense") {
        xmin = 40;
        xmax = 60;
      } else {
        xmin = 68;
        xmax = 88;
      }
      xstep = (xmax - xmin) / nx;
      xdomain = (function() {
        var m, ref1, ref2, ref3, results;
        results = [];
        for (x = m = ref1 = xmin, ref2 = xmax, ref3 = xstep; ref3 > 0 ? m <= ref2 : m >= ref2; x = m += ref3) {
          results.push(x);
        }
        return results;
      })();
      tick_list = (function() {
        var m, ref1, results;
        results = [];
        for (tick = m = 0, ref1 = nx; m <= ref1; tick = m += 2) {
          results.push(tick);
        }
        return results;
      })();
      xaxis_tickValues = (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = tick_list.length; m < len1; m++) {
          tick = tick_list[m];
          results.push(xdomain[tick]);
        }
        return results;
      })();
      data_select = _.filter(data, function(d) {
        var is_field, is_sense;
        is_sense = d.tBase === "50";
        is_field = d.tBase === "80";
        if (is_sense && sense_or_field !== "sense") {
          return false;
        } else if (is_field && sense_or_field !== "field") {
          return false;
        } else {
          return layerCheckList[d.layerID - 1];
        }
      });
      entries = _.countBy(data_select, function(d) {
        return Math.floor((d.tens - xmin) / xstep);
      });
      bindatum = _.map(xdomain, function(e, i) {
        return {
          itens: xdomain[i],
          ents: e != null ? e : 0
        };
      });
      ydomain = [
        0, d3.max(bindatum, function(d) {
          return d.ents;
        })
      ];
      if (first_call_hist[sense_or_field]) {
        d3.select("#menu_tension").append("div").attr("id", "menu_tension_" + sense_or_field);
        this.svg_tension_hist[sense_or_field] = append_svg("#menu_tension_" + sense_or_field);
        this.first_call_hist[sense_or_field] = false;
      }
      this.frame_tension_hist[sense_or_field] = make_frame(this.svg_tension_hist[sense_or_field], "tension (g)", "#/g", xdomain, ydomain, {
        xaxis_type: "roundBands",
        xaxis_tickValues: xaxis_tickValues
      });
      makeBarChart(this.frame_tension_hist[sense_or_field], bindatum, "itens", "ents", (function() {
        if (sense_or_field === "sense") {
          return "#ed5454";
        } else {
          return "#3874e3";
        }
      }), {
        label: [
          {
            data: ["ents"]
          }
        ]
      });
      tension_mean = _.reduce(data_select, (function(memo, d) {
        return memo + d.tens;
      }), 0) / data_select.length;
      tension_rms = _.reduce(data_select, (function(memo, d) {
        return memo + Math.pow(d.tens - tension_mean, 2);
      }), 0) / data_select.length;
      tension_rms = Math.sqrt(tension_rms);
      frac_rms = (tension_rms / tension_mean * 100).toFixed(0);
      makeStatBox(frame_tension_hist[sense_or_field], w - 250, 20, "Mean " + (tension_mean.toFixed(2)) + " g");
      return makeStatBox(frame_tension_hist[sense_or_field], w - 250, 40, "Rms " + (tension_rms.toFixed(2)) + " g (" + frac_rms + " '%')");
    };

    return TensionHistogram;

  })();

  $(function() {
    var onFileLoad, s3;
    $("#file").change(function() {
      var item, reader;
      console.log("called onFileInput");
      item = this.files[0];
      reader = new FileReader();
      reader.onload = onFileLoad;
      reader.readAsText(item);
    });
    onFileLoad = function(e) {
      var parser, xmlDoc;
      parser = new DOMParser();
      xmlDoc = parser.parseFromString(e.target.result, "text/xml");
      console.log(xmlDoc);
    };
    s3 = new S3();
    s3.getObject("stats/stats.json", function(url) {
      return d3.json(url, function(error, dailies) {
        console.log(dailies);
        Progress.plot(dailies);
        Load.plot(dailies);
        s3.getObject("csv/tension_bar.csv", function(url) {
          d3.csv(url, function(error, csv) {});
          return TensionBar.plot(csv, dailies);
        });
        return s3.getObject("daily/current/data.json", function(url) {
          return d3.json(url, function(error, data) {
            Endplate.plot(data, dailies[dailies.length - 1]);
            Tension.plot(data);
            TensionHistogram.plot(data, "sense");
            TensionHistogram.plot(data, "field");
            return Progress.plotLayerDays(data);
          });
        });
      });
    });
    return s3.getObject("csv/dial_gauge.csv", function(url) {
      return d3.csv(url, function(error, csv) {
        return DialGauge.plot(csv);
      });
    });
  });

}).call(this);
