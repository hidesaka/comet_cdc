// Generated by CoffeeScript 1.9.3
(function() {
  var DialGauge, Endplate, LayerSelection, Loading, Progress, S3, TempHumid, Tension, TensionHistogram, append_svg, diam, g_layerCheckList, get_last_date, get_xypos, h, height, holes, i, j, k, l, len, makeBarChart, makeLine, makeScatterPlot, makeStatBox, makeTooltip, make_daily_data, make_frame, make_stat, margin, num, numTotalWires, numWires, ref, spin_opts, w, width;

  spin_opts = {
    lines: 13,
    length: 28,
    width: 14,
    radius: 42,
    scale: 1,
    corners: 1,
    color: '#000',
    opacity: 0.25,
    rotate: 0,
    direction: 1,
    speed: 1,
    trail: 60,
    fps: 20,
    zIndex: 2e9,
    className: 'spinner',
    top: '60%',
    left: '40%',
    shadow: false,
    hwaccel: false,
    position: 'absolute'
  };

  diam = 180;

  w = 650;

  h = 650;

  margin = {
    top: 20,
    right: 150,
    bottom: 50,
    left: 80
  };

  width = w - margin.left - margin.right;

  height = 300 - margin.top - margin.bottom;

  numWires = [396, 396, 396, 408, 408, 420, 420, 432, 432, 444, 444, 456, 456, 468, 468, 480, 480, 492, 492, 504, 504, 516, 516, 528, 528, 540, 540, 552, 552, 564, 564, 576, 576, 588, 588, 600, 600, 612, 612];

  numTotalWires = _.reduce(numWires, function(memo, num) {
    return memo + num;
  });

  get_xypos = function(layerid, wireid, num_wires) {
    var deg, r, rad, x, y;
    r = 50 + (layerid - 1);
    deg = (wireid - 1) / num_wires * 360;
    rad = deg / 180.0 * Math.PI;
    x = r * Math.cos(rad);
    y = r * Math.sin(rad);
    return {
      x: x,
      y: y
    };
  };

  holes = [];

  for (i = k = 0, len = numWires.length; k < len; i = ++k) {
    num = numWires[i];
    for (j = l = 0, ref = num; 0 <= ref ? l <= ref : l >= ref; j = 0 <= ref ? ++l : --l) {
      holes.push(get_xypos(i + 1, j + 1, numWires[i]));
    }
  }

  get_last_date = function(now_utime_sec, num_wires, num_ave) {
    var day, last_date, last_day, last_utime_ms, num_holidays, remaining_days, remaining_wires, remaining_work_days, string_speed, work_days;
    remaining_wires = numTotalWires - num_wires;
    string_speed = num_ave;
    remaining_work_days = remaining_wires / string_speed;
    num_holidays = 0;
    remaining_days = 1;
    work_days = 1;
    while (true) {
      if (work_days >= remaining_work_days) {
        break;
      }
      day = new Date((now_utime_sec + remaining_days * 24 * 60 * 60) * 1000);
      if (day.getDay() === 0 || day.getDay() === 6) {
        num_holidays += 1;
        remaining_days += 1;
        continue;
      }
      if ((day.getMonth() + 1) === 8 && day.getDate() === 13) {
        num_holidays += 1;
        remaining_days += 1;
        continue;
      }
      if ((day.getMonth() + 1) === 8 && day.getDate() === 14) {
        num_holidays += 1;
        remaining_days += 1;
        continue;
      }
      remaining_days += 1;
      work_days += 1;
    }
    last_utime_ms = (now_utime_sec + remaining_days * 24 * 60 * 60) * 1000;
    last_date = new Date(last_utime_ms);
    last_day = (last_date.getFullYear()) + "/" + (last_date.getMonth() + 1) + "/" + (last_date.getDate());
    return [last_day, last_utime_ms];
  };

  make_daily_data = function(xml) {
    var data, dataID, date, date_as_int, datum, density, freq, latest_date, layer, layerID, layerid, len1, m, n, tBase, tens, today_date, today_dir, wire, wireID;
    today_date = "";
    today_dir = "";
    latest_date = 0;
    datum = [];
    for (layerid = m = 1; m <= 39; layerid = ++m) {
      layerID = layerid;
      layer = xml.getElementsByTagName("T_Data" + layerid);
      for (i = n = 0, len1 = layer.length; n < len1; i = ++n) {
        wire = layer[i];
        dataID = wire.getElementsByTagName("DataID")[0].childNodes[0].nodeValue;
        wireID = parseInt(wire.getElementsByTagName("WireID")[0].childNodes[0].nodeValue);
        if (!wire.getElementsByTagName("Density1")[0]) {
          continue;
        }
        density = wire.getElementsByTagName("Density1")[0].childNodes[0].nodeValue;
        tBase = wire.getElementsByTagName("TBase")[0].childNodes[0].nodeValue;
        date = wire.getElementsByTagName("Date1")[0].childNodes[0].nodeValue;
        freq = wire.getElementsByTagName("Frq1")[0].childNodes[0].nodeValue;
        tens = wire.getElementsByTagName("Ten1")[0].childNodes[0].nodeValue;
        data = {
          dataID: dataID,
          layerID: layerID,
          wireID: wireID,
          tBase: tBase,
          density: density,
          date: date,
          freq: freq,
          tens: tens
        };
        datum.push(data);
        date_as_int = parseInt(date.replace(/\//g, ''));
        if (date_as_int > latest_date) {
          latest_date = date_as_int;
          today_date = date;
          today_dir = date_as_int;
        }
      }
    }
    return [today_date, today_dir, datum];
  };

  make_stat = function(today_date, prev_stat, daily_data) {
    var d, days, last_date, last_utime, len1, m, num_ave, num_bad, num_day, num_field, num_sense, num_sum, ref1, stat, utime, wire_tension_kg;
    days = prev_stat == null ? 1 : prev_stat.days + 1;
    utime = new Date(today_date + " 00:00:00").getTime();
    num_sum = daily_data.length;
    num_sense = _.filter(daily_data, function(d) {
      return d.tBase === "50";
    }).length;
    num_field = _.filter(daily_data, function(d) {
      return d.tBase === "80";
    }).length;
    num_day = prev_stat == null ? daily_data.length : daily_data.length - prev_stat.num_sum;
    wire_tension_kg = _.reduce(daily_data, (function(memo, d) {
      return memo + d.tens * 0.001;
    }), 0);
    num_ave = parseInt(daily_data.length / days);
    num_bad = 0;
    for (m = 0, len1 = daily_data.length; m < len1; m++) {
      d = daily_data[m];
      if (d.tBase === "50" && (d.tens < 45.0 || d.tens > 55.0)) {
        num_bad++;
      }
      if (d.tBase === "80" && (d.tens < 72.0 || d.tens > 88.0)) {
        num_bad++;
      }
    }
    ref1 = get_last_date(utime / 1000, num_sum, num_ave), last_date = ref1[0], last_utime = ref1[1];
    stat = {
      date: today_date,
      utime: utime,
      days: days,
      num_sum: num_sum,
      num_sense: num_sense,
      num_field: num_field,
      num_day: num_day,
      num_ave: num_ave,
      num_bad: num_bad,
      wire_tension_kg: wire_tension_kg,
      last_date: last_date,
      last_utime: last_utime
    };
    return stat;
  };

  append_svg = function(id) {
    return d3.select(id).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + ", " + margin.top + ")");
  };

  make_frame = function(svg, xtitle, ytitle, xdomain, ydomain, options) {
    var tick_label_dx, tick_label_dy, tick_label_rotate, xAxis, xScale, xx, yAxis, yScale;
    svg.selectAll("g").remove();
    xScale = "";
    if (options.xaxis_type === "roundBands") {
      xScale = d3.scale.ordinal().domain(xdomain).rangeRoundBands([0, width]);
    } else if (options.xaxis_type === "time") {
      xScale = d3.time.scale().domain(xdomain).range([0, width]).nice();
    } else {
      xScale = d3.scale.linear().domain(xdomain).range([0, width]);
    }
    yScale = d3.scale.linear().domain(ydomain).range([height, 0]).nice();
    if (!options.no_axis) {
      tick_label_dx = 0;
      tick_label_dy = 10;
      tick_label_rotate = "0";
      xAxis = d3.svg.axis().scale(xScale).orient("bottom");
      if (options.xaxis_tickValues != null) {
        xAxis.tickValues(options.xaxis_tickValues);
      }
      if (options.xaxis_type === "time") {
        xAxis.ticks(5).tickFormat(d3.time.format('%b %d'));
        tick_label_rotate = "-65";
        tick_label_dx = -30;
        tick_label_dy = -1;
      }
      yAxis = d3.svg.axis().scale(yScale).orient("left");
      xx = svg.append("g").attr("class", "axis").attr("transform", "translate(0," + height + ")").call(xAxis);
      xx.selectAll("text").attr("transform", "rotate(" + tick_label_rotate + ")").attr("text-anchor", "start").attr("dx", tick_label_dx).attr("dy", tick_label_dy);
      xx.append("text").attr("x", width + 8).attr("y", 10).attr("text-anchor", "start").text(xtitle);
    }
    svg.append("g").attr("class", "axis").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", -55).attr("dy", ".71em").style("text-anchor", "end").text(ytitle);
    return {
      "svg": svg,
      "xScale": xScale,
      "yScale": yScale
    };
  };

  makeBarChart = function(frame, data, xdata, ydata, fillColor, tooltip) {
    frame.svg.selectAll("rect").remove();
    frame.svg.selectAll(".bar").data(data).enter().append("rect").attr("fill", fillColor).attr("x", function(d) {
      return frame.xScale(d[xdata]);
    }).attr("width", frame.xScale.rangeBand() * 0.97).attr("y", height).attr("height", 0).transition().duration(1000).attr("y", function(d, i) {
      return frame.yScale(d[ydata]);
    }).attr("height", function(d) {
      return height - frame.yScale(d[ydata]);
    });
    if (tooltip) {
      return makeTooltip(frame, "rect", data, xdata, ydata, tooltip.label);
    }
  };

  makeScatterPlot = function(frame, data, xdata, ydata, options, legend_entry, tooltip) {
    var legend, line;
    if (options.line_stroke) {
      line = d3.svg.line().x(function(d) {
        return frame.xScale(d[xdata]);
      }).y(function(d) {
        return frame.yScale(d[ydata]);
      });
      frame.svg.append("path").attr("stroke", options.line_stroke).attr("fill", "none").attr("d", line(data));
    }
    frame.svg.selectAll("circle").remove();
    if (legend_entry.length !== 0) {
      legend = frame.svg.append("g").attr("x", width - 65).attr("y", 25).attr("height", 100).attr("width", 100).selectAll("text").data(legend_entry).enter().append("text").attr("x", w - 180).attr("y", function(d) {
        return d.ypos;
      }).attr("height", 30).attr("width", 100).style("fill", function(d) {
        return d.stroke;
      }).text(function(d) {
        return d.label;
      });
      frame.svg.append("g").attr("x", width - 75).attr("y", 25).attr("height", 100).attr("width", 100).selectAll(".circle").data(legend_entry).enter().append("circle").attr("cx", w - 190).attr("cy", function(d) {
        return d.ypos - 4;
      }).attr("r", 3).attr("fill", function(d) {
        return d.fill;
      }).attr("stroke", function(d) {
        return d.stroke;
      }).attr("stroke-width", "1px");
    }
    frame.svg.selectAll(".circle").data(data).enter().append("g").attr("class", "dot").append("circle").attr("cx", function(d, i) {
      return frame.xScale(d[xdata]);
    }).attr("cy", function(d, i) {
      return frame.yScale(d[ydata]);
    }).attr("r", options.r).attr("fill", options.fill).attr("stroke", options.stroke).attr("stroke-width", options.stroke_width);
    if (tooltip) {
      return makeTooltip(frame, ".dot circle", data, xdata, ydata, tooltip.label);
    }
  };

  makeLine = function(frame, class_name, points) {
    var line;
    line = d3.svg.line().x(function(d) {
      return frame.xScale(d.x);
    }).y(function(d) {
      return frame.yScale(d.y);
    });
    return frame.svg.append("path").datum(points).attr("class", class_name).attr("d", line);
  };

  makeStatBox = function(frame, x, y, text) {
    frame.svg.select("text").remove();
    return frame.svg.append("text").attr("x", x).attr("y", y).text(text);
  };

  makeTooltip = function(frame, class_name, data, xdata, ydata, labels) {
    var focus, get_msg;
    focus = frame.svg.append("g").attr("class", "focus").style("display", "none");
    focus.append("rect").attr("opacity", "0.6").attr("x", 9).attr("y", 9).attr("rx", 2).attr("ry", 2).attr("width", 30).attr("height", function() {
      if (labels.length === 1) {
        return 20;
      } else {
        return labels.length * 17;
      }
    });
    focus.selectAll("text").data(labels).enter().append("text").attr("x", 14).attr("y", 12).attr("font-family", "Inconsolata").attr("font-size", "10px").attr("fill", "white");
    get_msg = function(d, label, i) {
      var ent, len1, m, msg, ref1;
      msg = label.prefix || '';
      ref1 = label.data;
      for (i = m = 0, len1 = ref1.length; m < len1; i = ++m) {
        ent = ref1[i];
        if (typeof ent === 'function') {
          msg += ent(d);
        } else {
          msg += d[ent];
        }
        if (i < label.data.length - 1) {
          msg += label.separator || '';
        }
      }
      return msg += label.postfix || '';
    };
    return frame.svg.selectAll(class_name).data(data).on("mouseover", function() {
      return focus.style("display", null);
    }).on("mouseout", function() {
      return focus.style("display", "none");
    }).on("mousemove", function(d) {
      var xval, yval;
      xval = typeof xdata === 'function' ? xdata(d) : d[xdata];
      yval = typeof ydata === 'function' ? ydata(d) : d[ydata];
      focus.select("rect").attr("transform", "translate(" + frame.xScale(xval) + "," + (frame.yScale(yval) - 10) + ")");
      focus.select("rect").attr("width", function() {
        var line, max_len;
        line = [];
        focus.selectAll("text").each(function(label, i) {
          return line.push(get_msg(d, label, i));
        });
        max_len = d3.max(line, function(d) {
          return d.length;
        });
        return 14 + max_len * 4.7;
      });
      focus.selectAll("text").attr("transform", function(_, i) {
        return "translate(" + (frame.xScale(xval)) + ", " + (frame.yScale(yval) + i * 15) + ")";
      });
      return focus.selectAll("text").text(function(label, i) {
        return get_msg(d, label, i);
      });
    });
  };

  S3 = (function() {
    function S3() {
      this.awsRegion = "us-east-1";
      this.cognitoParams = {
        IdentityPoolId: "us-east-1:435dfdc9-d483-4f5e-8f8b-27e3569ad9af"
      };
      this.s3BucketName = "comet-cdc";
      this.s3RegionName = "ap-northeast-1";
      AWS.config.region = this.awsRegion;
      AWS.config.credentials = new AWS.CognitoIdentityCredentials(this.cognitoParams);
      AWS.config.credentials.get(function(err) {
        if (!err) {
          return console.log("Cognito Identity Id: " + AWS.config.credentials.identityId);
        }
      });
      this.s3 = new AWS.S3({
        params: {
          Bucket: this.s3BucketName,
          Region: this.s3RegionName
        }
      });
      console.log("=== s3 ====");
      console.log(this.s3);
      console.log("===========");
    }

    S3.prototype.getObject = function(name, callback) {
      return this.s3.listObjects((function(_this) {
        return function(err, data) {
          var len1, m, obj, ref1, results;
          ref1 = data.Contents;
          results = [];
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            obj = ref1[m];
            if (obj.Key === name) {
              results.push(callback(_this.s3.getSignedUrl('getObject', {
                Bucket: _this.s3BucketName,
                Key: obj.Key
              })));
            }
          }
          return results;
        };
      })(this));
    };

    S3.prototype.putObject = function(name, body, callback_upload, callback_progress) {
      var params, upload;
      params = {
        Key: name,
        Body: body
      };
      upload = this.s3.upload(params, function(err, data) {
        return callback_upload(err, data);
      });
      return upload.on('httpUploadProgress', function(event) {
        return callback_progress(event);
      });
    };

    S3.prototype.putObjectWithProgress = function(name, body, div_file, div_msg, div_bar) {
      $(div_msg).show();
      $(div_bar).attr("value", 0);
      $(div_bar).show();
      $(div_file).attr("disabled", "disabled");
      return this.putObject(name, body, function(err, data) {
        if (err) {
          return console.log("there is error on s3.putObject " + err);
        } else {
          console.log("succeed to upload " + name);
          $(div_file).val("").removeAttr("disabled");
          $(div_msg).html("done!").fadeOut(3000);
          return $(div_bar).fadeOut(3000);
        }
      }, function(event) {
        var progre;
        progre = parseInt(event.loaded / event.total * 10000) / 100;
        $(div_msg).height("30px");
        $(div_msg).html("Uploading.. " + progre + "%");
        return $(div_bar).attr("value", progre);
      });
    };

    S3.prototype.getJSON_prev_stat = function(today, callback) {
      var latest_date, today_as_int;
      today_as_int = parseInt(today);
      latest_date = "";
      return this.s3.listObjects((function(_this) {
        return function(err, data) {
          var a, date_as_int, len1, m, obj, ref1;
          ref1 = data.Contents;
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            obj = ref1[m];
            a = obj.Key.match(/daily\/(\d\d\d\d\d\d\d\d)\/stat.json/);
            if (!a) {
              continue;
            }
            date_as_int = parseInt(a[1]);
            if (date_as_int < today_as_int) {
              latest_date = a[1];
            }
          }
          return _this.getObject("daily/" + latest_date + "/stat.json", function(url) {
            return d3.json(url, function(data) {
              return callback(data);
            });
          });
        };
      })(this));
    };

    S3.prototype.getJSON_stats = function(callback) {
      return this.s3.listObjects((function(_this) {
        return function(err, data) {
          var len1, m, obj, ref1, results;
          ref1 = data.Contents;
          results = [];
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            obj = ref1[m];
            if (obj.Key === "stats/stats.json") {
              results.push(_this.getObject(obj.Key, function(url) {
                return d3.json(url, function(data) {
                  return callback(data);
                });
              }));
            }
          }
          return results;
        };
      })(this));
    };

    return S3;

  })();

  DialGauge = (function() {
    function DialGauge() {}

    DialGauge.read_csv = function(csv) {
      var d1, d2, d3, d4, data, date, ent, len1, m, temp, time, utime, v1, v11, v12, v1_start, v2, v21, v22, v2_start, v3, v31, v32, v3_start, v4, v41, v42, v4_start;
      j = 0;
      data = [];
      for (m = 0, len1 = csv.length; m < len1; m++) {
        ent = csv[m];
        v11 = ent["10deg_1mm"];
        v12 = ent["10deg_10um"];
        v21 = ent["90deg_1mm"];
        v22 = ent["90deg_10um"];
        v31 = ent["180deg_1mm"];
        v32 = ent["180deg_10um"];
        v41 = ent["270deg_1mm"];
        v42 = ent["270deg_10um"];
        if (!v11 || !v21 || !v31 || !v41) {
          continue;
        }
        if (!v12 || !v22 || !v32 || !v42) {
          continue;
        }
        v1 = (parseFloat(v11) + parseFloat(v12)) * 1000;
        v2 = (parseFloat(v21) + parseFloat(v22)) * 1000;
        v3 = (parseFloat(v31) + parseFloat(v32)) * 1000;
        v4 = (parseFloat(v41) + parseFloat(v42)) * 1000;
        if (j === 0) {
          v1_start = v1;
          v2_start = v2;
          v3_start = v3;
          v4_start = v4;
        }
        d1 = v1 - v1_start;
        d2 = v2 - v2_start;
        d3 = v3 - v3_start;
        d4 = v4 - v4_start;
        utime = Date.parse(ent["Date"] + " " + ent["Time"]);
        date = ent["Date"];
        time = ent["Time"];
        temp = ent["Temp"];
        data[j++] = {
          "utime": utime,
          "date": date,
          "time": time,
          "temp": temp,
          "location": "at10deg",
          "disp_um": parseFloat(d1)
        };
        data[j++] = {
          "utime": utime,
          "date": date,
          "time": time,
          "temp": temp,
          "location": "at90deg",
          "disp_um": parseFloat(d2)
        };
        data[j++] = {
          "utime": utime,
          "date": date,
          "time": time,
          "temp": temp,
          "location": "at180deg",
          "disp_um": parseFloat(d3)
        };
        data[j++] = {
          "utime": utime,
          "date": date,
          "time": time,
          "temp": temp,
          "location": "at270deg",
          "disp_um": parseFloat(d4)
        };
      }
      return data;
    };

    DialGauge.plot = function(csv) {
      var fill_gauge, frame_gauge, gauge_data, stroke_gauge, svg_gauge, xdomain_gauge, ydomain_gauge;
      gauge_data = this.read_csv(csv);
      xdomain_gauge = d3.extent(gauge_data, function(d) {
        return d.utime;
      });
      ydomain_gauge = d3.extent(gauge_data, function(d) {
        return d.disp_um;
      });
      svg_gauge = append_svg("#menu_gauge");
      frame_gauge = make_frame(svg_gauge, "date", "displacement (um)", xdomain_gauge, ydomain_gauge, {
        xaxis_type: "time"
      });
      stroke_gauge = {
        at10deg: "#ed5454",
        at90deg: "#3874e3",
        at180deg: "#228b22",
        at270deg: "#ffa500"
      };
      fill_gauge = {
        at10deg: "#f8d7d7",
        at90deg: "#bdd0f4",
        at180deg: "#9acd32",
        at270deg: "#ffead6"
      };
      return makeScatterPlot(frame_gauge, gauge_data, "utime", "disp_um", {
        r: 3,
        fill: function(d) {
          return fill_gauge[d.location];
        },
        stroke: function(d) {
          return stroke_gauge[d.location];
        },
        stroke_width: "1px"
      }, [
        {
          label: "10deg",
          stroke: '#ed5454',
          fill: "#f8d7d7",
          ypos: "66"
        }, {
          label: "90deg",
          stroke: '#3874e3',
          fill: "#bdd0f4",
          ypos: "83"
        }, {
          label: "180deg",
          stroke: '#228b22',
          fill: "#9acd32",
          ypos: "100"
        }, {
          label: "270deg",
          stroke: '#ffa500',
          fill: "#ffead6",
          ypos: "117"
        }
      ], {
        label: [
          {
            data: [
              "date", "time", function(d) {
                return d.disp_um.toFixed(0);
              }
            ],
            separator: ' ',
            postfix: ' um'
          }
        ]
      });
    };

    return DialGauge;

  })();

  Loading = (function() {
    function Loading() {}

    Loading.read_csv = function(csv) {
      var d1, d2, data, ent, len1, m, tension_kg, utime;
      data = [];
      for (m = 0, len1 = csv.length; m < len1; m++) {
        ent = csv[m];
        d1 = ent["Date"];
        d2 = ent["Tension_kg"];
        if (_.isEmpty(d1) || _.isEmpty(d2)) {
          continue;
        }
        utime = Date.parse(d1);
        tension_kg = parseFloat(d2);
        data.push({
          utime: utime,
          tension_kg: tension_kg
        });
      }
      return data;
    };

    Loading.plot = function(csv, dailies) {
      var bar, bar_data, daily, frame_all, frame_bar, frame_wire, jnext, labelA, len1, len2, m, n, svg_all, svg_bar, svg_wire, xdomain, ydomain_all, ydomain_bar, ydomain_wire;
      bar_data = Loading.read_csv(csv);
      for (i = m = 0, len1 = dailies.length; m < len1; i = ++m) {
        daily = dailies[i];
        jnext = -1;
        for (j = n = 0, len2 = bar_data.length; n < len2; j = ++n) {
          bar = bar_data[j];
          if (bar.utime > daily.utime) {
            jnext = j;
            break;
          }
        }
        if (jnext === -1) {
          jnext = bar_data.length;
        }
        daily.bar_tension_kg = bar_data[jnext - 1].tension_kg;
        daily.all_tension_kg = daily.wire_tension_kg + bar_data[jnext - 1].tension_kg;
      }
      xdomain = d3.extent(dailies, function(d) {
        return d.utime;
      });
      labelA = (function(d) {
        return d.date;
      });
      ydomain_wire = [0, dailies[dailies.length - 1].wire_tension_kg];
      svg_wire = append_svg("#menu_load_wire");
      frame_wire = make_frame(svg_wire, "date", "loading of wires (kg)", xdomain, ydomain_wire, {
        xaxis_type: "time"
      });
      makeScatterPlot(frame_wire, dailies, "utime", "wire_tension_kg", {
        r: 3,
        stroke: "#ff1493",
        fill: "#ff69b4",
        stroke_width: "1px",
        line_stroke: "#ff1493"
      }, [], {
        label: [
          {
            data: [
              labelA, (function(d) {
                return (d.wire_tension_kg.toFixed(1)) + " kg";
              })
            ],
            separator: ' '
          }
        ]
      });
      ydomain_all = [
        0.9 * d3.min(dailies, function(d) {
          return d.all_tension_kg;
        }), 1.1 * d3.max(dailies, function(d) {
          return d.all_tension_kg;
        })
      ];
      svg_all = append_svg("#menu_load_all");
      frame_all = make_frame(svg_all, "date", "total loading (kg)", xdomain, ydomain_all, {
        xaxis_type: "time"
      });
      makeScatterPlot(frame_all, dailies, "utime", "all_tension_kg", {
        r: 3,
        fill: "#9966ff",
        stroke: "#6633cc",
        stroke_width: "1px",
        line_stroke: "#6633cc"
      }, [], {
        label: [
          {
            data: [
              labelA, (function(d) {
                return (d.all_tension_kg.toFixed(1)) + " kg";
              })
            ],
            separator: ' '
          }
        ]
      });
      ydomain_bar = [
        0.9 * d3.min(dailies, (function(d) {
          return d.bar_tension_kg;
        })), 1.1 * d3.max(dailies, (function(d) {
          return d.bar_tension_kg;
        }))
      ];
      svg_bar = append_svg("#menu_load_bar");
      frame_bar = make_frame(svg_bar, "date", "loading of tension bars (kg)", xdomain, ydomain_bar, {
        xaxis_type: "time"
      });
      return makeScatterPlot(frame_bar, dailies, "utime", "bar_tension_kg", {
        r: 3,
        fill: "#0081B8",
        stroke: "blue",
        stroke_width: "1px",
        line_stroke: "blue"
      }, [], {
        label: [
          {
            data: [
              labelA, (function(d) {
                return (d.bar_tension_kg.toFixed(1)) + " kg";
              })
            ],
            separator: ' '
          }
        ]
      });
    };

    return Loading;

  })();

  Progress = (function() {
    function Progress() {}

    Progress.plot = function(dailies) {
      var d, dailies_subtract, day_space, frame_progress_ave, frame_progress_bad, frame_progress_day, frame_progress_sum, num_bins, svg_progress_ave, svg_progress_bad, svg_progress_day, svg_progress_sum, xaxis_tickValues, xdomain, ydomain_ave, ydomain_bad, ydomain_day, ydomain_sum;
      xdomain = (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = dailies.length; m < len1; m++) {
          d = dailies[m];
          results.push(d.days);
        }
        return results;
      })();
      ydomain_sum = [
        0, d3.max(dailies, function(d) {
          return d.num_sum;
        })
      ];
      ydomain_day = [
        0, d3.max(dailies, function(d) {
          return d.num_day;
        })
      ];
      ydomain_ave = [
        0, d3.max(dailies, function(d) {
          return d.num_ave;
        })
      ];
      ydomain_bad = [
        0, d3.max(dailies, function(d) {
          return d.num_bad;
        })
      ];
      num_bins = 15;
      day_space = xdomain.length / num_bins;
      day_space = parseInt(day_space);
      console.log("num_bins " + num_bins);
      console.log("day_space " + day_space);
      console.log("xdomain.length " + xdomain.length);
      xaxis_tickValues = (function() {
        var len1, m, ref1, results;
        ref1 = day_space;
        results = [];
        for ((ref1 > 0 ? (m = 0, len1 = dailies.length) : m = dailies.length - 1); ref1 > 0 ? m < len1 : m >= 0; m += ref1) {
          d = dailies[m];
          results.push(d.days);
        }
        return results;
      })();
      console.log("xaxis_tickValues " + xaxis_tickValues);
      svg_progress_sum = append_svg("#menu_progress #progress_sum");
      svg_progress_day = append_svg("#menu_progress #progress_day");
      svg_progress_ave = append_svg("#menu_progress #progress_ave");
      svg_progress_bad = append_svg("#menu_progress #bad_wires");
      frame_progress_sum = make_frame(svg_progress_sum, "days", "total # of stringed wires", xdomain, ydomain_sum, {
        xaxis_type: "roundBands",
        xaxis_tickValues: xaxis_tickValues
      });
      frame_progress_day = make_frame(svg_progress_day, "days", "# of stringed wires", xdomain, ydomain_day, {
        xaxis_type: "roundBands",
        xaxis_tickValues: xaxis_tickValues
      });
      frame_progress_ave = make_frame(svg_progress_ave, "days", "ave # of stringed wires", xdomain, ydomain_ave, {
        xaxis_type: "roundBands",
        xaxis_tickValues: xaxis_tickValues
      });
      frame_progress_bad = make_frame(svg_progress_bad, "days", "# of wires to be re-stringed", xdomain, ydomain_bad, {
        xaxis_type: "roundBands",
        xaxis_tickValues: xaxis_tickValues
      });
      $("#last_day").html("Finished on " + new Date(_.last(dailies).last_utime).toLocaleDateString("ja-JP"));
      makeBarChart(frame_progress_sum, dailies, "days", "num_sum", "#D70071", {
        label: [
          {
            data: ["num_sum"]
          }
        ]
      });
      makeBarChart(frame_progress_ave, dailies, "days", "num_ave", "#91D48C", {
        label: [
          {
            data: [
              function(d) {
                return d.num_ave.toFixed(1);
              }
            ]
          }
        ]
      });
      makeBarChart(frame_progress_day, dailies, "days", "num_day", "steelblue", {
        label: [
          {
            data: ["num_day"]
          }
        ]
      });
      dailies_subtract = _.map(dailies, function(value, index, list) {
        if (index > 96) {
          value.num_bad = value.num_bad - 105;
        }
        return value;
      });
      console.log("dalies_subtract");
      console.log(dailies_subtract);
      return makeBarChart(frame_progress_bad, dailies_subtract, "days", "num_bad", "#6521A0", {
        label: [
          {
            data: ["num_bad"]
          }
        ]
      });
    };

    Progress.plotLayerDays = function(data) {
      var d, frame, layerData, layerNumbers, mydata, svg, x, xaxis_tickValues, xdomain, xmax, xmin, ydomain;
      layerData = _.groupBy(data, function(d) {
        return parseInt(d.layerID);
      });
      layerNumbers = _.keys(layerData);
      xmin = _.min(layerNumbers, _.identity);
      xmax = _.max(layerNumbers, _.identity);
      xmin = parseInt(xmin);
      xmax = parseInt(xmax);
      mydata = (function() {
        var m, results;
        results = [];
        for (d = m = 1; m <= 39; d = ++m) {
          results.push({
            layerID: d,
            num_days: 0
          });
        }
        return results;
      })();
      _.each(layerData, function(v, layerID) {
        var days, num_days;
        days = _.groupBy(v, function(d2) {
          return d2.date;
        });
        num_days = _.keys(days).length;
        mydata[layerID - 1].layerID = layerID;
        return mydata[layerID - 1].num_days = num_days;
      });
      svg = append_svg("#menu_progress #layer_days");
      xdomain = (function() {
        var m, results;
        results = [];
        for (x = m = 0; m <= 40; x = ++m) {
          results.push(x);
        }
        return results;
      })();
      ydomain = [0, 10];
      xaxis_tickValues = (function() {
        var m, results;
        results = [];
        for (x = m = 0; m <= 40; x = m += 5) {
          results.push(x);
        }
        return results;
      })();
      frame = make_frame(svg, "layer_id", "days", xdomain, ydomain, {
        xaxis_type: "roundBands",
        xaxis_tickValues: xaxis_tickValues
      });
      return makeBarChart(frame, mydata, "layerID", "num_days", "#A8BE62", {
        label: [
          {
            data: ["layerID"],
            prefix: 'layer_id '
          }, {
            data: ["num_days"],
            postfix: ' days'
          }
        ]
      });
    };

    return Progress;

  })();

  Endplate = (function() {
    function Endplate() {}

    Endplate.plot = function(data, current) {
      var svg;
      svg = d3.select("#menu_status #status").append("svg").attr({
        width: w,
        height: h
      });
      svg.selectAll("circle").data(holes).enter().append("circle").attr("cx", (function(d) {
        return d.x / diam * w * 0.9 + w / 2.0;
      })).attr("cy", (function(d) {
        return -d.y / diam * h * 0.9 + h / 2.0;
      })).attr("r", 0.5).attr("flll", "gray");
      return svg.selectAll("circle.hoge").data(data).enter().append("circle").attr("cx", function(d) {
        return +get_xypos(d.layerID, d.wireID, numWires[d.layerID - 1])["x"] / diam * w * 0.9 + w / 2;
      }).attr("cy", function(d) {
        return -get_xypos(d.layerID, d.wireID, numWires[d.layerID - 1])["y"] / diam * h * 0.9 + h / 2;
      }).attr("r", function(d) {
        return 0;
      }).transition().delay(function(d, i) {
        return (1000 / data.length) * i;
      }).duration(3000).attr("r", function(d) {
        return 1.5;
      }).attr("stroke", function(d) {
        var base;
        return typeof (base = d.tbase === "50") === "function" ? base({
          "#f8d7d7": "#bdd0f4"
        }) : void 0;
      }).attr("fill", function(d) {
        if (d.tBase === "50") {
          return "#ed5454";
        } else {
          return "#3874e3";
        }
      }).attr("stroke_width", "1px").each("end", function() {
        var r2, r3, r4, texts;
        r2 = parseFloat(current.num_sum / numTotalWires * 100).toFixed(0);
        r3 = parseFloat(current.num_sense / 4986 * 100).toFixed(0);
        r4 = parseFloat(current.num_field / 14562 * 100).toFixed(0);
        texts = ["Days: " + current.days + " (" + current.date + ")", "Wire:  " + r2 + "% (" + current.num_sum + "/" + numTotalWires + ")", "Sense: " + r3 + "% (" + current.num_sense + "/4986)", "Field: " + r4 + "% (" + current.num_field + "/14562)"];
        return svg.selectAll("text").data(texts).enter().append('text').text(function(txt) {
          return txt;
        }).attr("x", function(_, i) {
          return w * 1.1 / 3.0;
        }).attr("y", function(_, i) {
          return h / 2.5 + (i + 1.0) * 25;
        }).attr("font-family", "HelveticaNeue-Light").attr("font-style", "italic").attr("font-size", function(_, i) {
          if (i === 0) {
            return "20px";
          } else {
            return "20px";
          }
        }).attr("text-anchor", function(_, i) {
          if (i === 0) {
            return "start";
          } else {
            return "start";
          }
        }).attr("fill", "none").transition().duration(1000).ease("linear").attr("fill", function(_, i) {
          if (i === 2) {
            return "#ed5454";
          } else if (i === 3) {
            return "#3874e3";
          } else {
            return "black";
          }
        });
      });
    };

    return Endplate;

  })();

  g_layerCheckList = [];

  LayerSelection = (function() {
    function LayerSelection() {}

    LayerSelection.plot = function(data) {
      var labels, layer_selection, p, texts;
      g_layerCheckList = (function() {
        var m, results;
        results = [];
        for (i = m = 0; m <= 38; i = ++m) {
          results.push(true);
        }
        return results;
      })();
      layer_selection = (function() {
        var m, results;
        results = [];
        for (i = m = 1; m <= 39; i = ++m) {
          results.push({
            layerid: i
          });
        }
        return results;
      })();
      labels = d3.select("#menu_tension").append("div").html("LayerID").attr("id", "layer_selection").selectAll(".test").data(layer_selection).enter().append("label").attr("class", "label_id_layers").text(function(d) {
        return d.layerid;
      }).insert("input").attr("type", "checkbox").property("checked", true).attr("id", function(d) {
        return "id_layer_" + d.layerid;
      }).attr("value", function(d) {
        return d.layerid;
      }).on("click", function(d) {
        var chk, msg;
        chk = d3.select(this).property("checked");
        msg = "layer " + d.layerid + " -> " + chk;
        g_layerCheckList[d.layerid - 1] = chk;
        Tension.plot(data);
        TensionHistogram.plot(data, "sense");
        return TensionHistogram.plot(data, "field");
      });
      p = d3.select("#menu_tension").append("p").attr("id", "layer_selection");
      texts = ["checkall", "uncheckall"];
      p.insert("select").attr("id", "layer_selection2").selectAll(".dummy").data(texts).enter().append("option").attr("value", function(d) {
        return d;
      }).append("text").text(function(d) {
        return d;
      });
      return d3.select("#layer_selection2").on("change", function(d) {
        var chk, val;
        val = d3.select(this).property("value");
        chk = val === "checkall" ? true : false;
        labels.property("checked", chk);
        g_layerCheckList = (function() {
          var m, results;
          results = [];
          for (i = m = 0; m < 39; i = ++m) {
            results.push(chk);
          }
          return results;
        })();
        Tension.plot(data);
        TensionHistogram.plot(data, "sense");
        return TensionHistogram.plot(data, "field");
      });
    };

    return LayerSelection;

  })();

  Tension = (function() {
    function Tension() {}

    Tension.first_call = true;

    Tension.plot = function(data) {
      var data_select, svg_tension, xdomain_tension, xmax, xmin, ydomain_tension;
      if (this.first_call) {
        xdomain_tension = [
          0, d3.max(data, function(d) {
            return parseInt(d.wireID);
          })
        ];
        ydomain_tension = [
          0, d3.max(data, function(d) {
            return parseFloat(d.tens);
          })
        ];
        svg_tension = append_svg("#menu_tension");
        this.frame_tension = make_frame(svg_tension, "wire_id", "tension (g)", xdomain_tension, ydomain_tension, {
          xaxis_type: "linear"
        });
        LayerSelection.plot(data);
        this.first_call = false;
      }
      xmin = d3.min(data, function(d) {
        return parseInt(d.wireID);
      });
      xmax = d3.max(data, function(d) {
        return parseFloat(d.wireID);
      });
      makeLine(this.frame_tension, "tension_limit_sense", [
        {
          x: xmin,
          y: 45
        }, {
          x: xmax,
          y: 45
        }
      ]);
      makeLine(this.frame_tension, "tension_limit_sense", [
        {
          x: xmin,
          y: 55
        }, {
          x: xmax,
          y: 55
        }
      ]);
      makeLine(this.frame_tension, "tension_limit_field", [
        {
          x: xmin,
          y: 72
        }, {
          x: xmax,
          y: 72
        }
      ]);
      makeLine(this.frame_tension, "tension_limit_field", [
        {
          x: xmin,
          y: 88
        }, {
          x: xmax,
          y: 88
        }
      ]);
      data_select = _.filter(data, function(d) {
        return g_layerCheckList[d.layerID - 1];
      });
      return makeScatterPlot(this.frame_tension, data_select, "wireID", "tens", {
        r: 3,
        stroke: (function(d) {
          if (d.tBase === "80") {
            return "#3874e3";
          } else {
            return "#ed5454";
          }
        }),
        fill: (function(d) {
          if (d.tBase === "80") {
            return "#bdd0f4";
          } else {
            return "#f8d7d7";
          }
        }),
        stroke_width: function(d) {
          if (d.tens < d.tBase * 0.9 || d.tens > d.tBase * 1.1) {
            return "1px";
          } else {
            return "0px";
          }
        }
      }, [
        {
          label: "sense",
          stroke: "#ed5454",
          fill: "#f8d7d7",
          ypos: "15"
        }, {
          label: "field",
          stroke: "#3874e3",
          fill: "#bdd0f4",
          ypos: "30"
        }
      ], {
        label: [
          {
            data: ["date"]
          }, {
            data: ["layerID", "wireID"],
            separator: '-'
          }, {
            data: ["tens"],
            postfix: ' g'
          }
        ]
      });
    };

    return Tension;

  })();

  TensionHistogram = (function() {
    function TensionHistogram() {}

    TensionHistogram.svg_tension_hist = {};

    TensionHistogram.frame_tension_hist = {};

    TensionHistogram.first_call_hist = {
      "sense": true,
      "field": true
    };

    TensionHistogram.plot = function(data, sense_or_field) {
      var bindatum, data_select, entries, frac_rms, nx, tension_mean, tension_rms, tick, tick_list, x, xaxis_tickValues, xdomain, xmax, xmin, xstep, ydomain;
      nx = 20;
      if (sense_or_field === "sense") {
        xmin = 40;
        xmax = 60;
      } else {
        xmin = 68;
        xmax = 88;
      }
      xstep = (xmax - xmin) / nx;
      xdomain = (function() {
        var m, ref1, ref2, ref3, results;
        results = [];
        for (x = m = ref1 = xmin, ref2 = xmax, ref3 = xstep; ref3 > 0 ? m <= ref2 : m >= ref2; x = m += ref3) {
          results.push(x);
        }
        return results;
      })();
      tick_list = (function() {
        var m, ref1, results;
        results = [];
        for (tick = m = 0, ref1 = nx; m <= ref1; tick = m += 2) {
          results.push(tick);
        }
        return results;
      })();
      xaxis_tickValues = (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = tick_list.length; m < len1; m++) {
          tick = tick_list[m];
          results.push(xdomain[tick]);
        }
        return results;
      })();
      data_select = _.filter(data, function(d) {
        var is_field, is_sense;
        is_sense = d.tBase === "50";
        is_field = d.tBase === "80";
        if (is_sense && sense_or_field !== "sense") {
          return false;
        } else if (is_field && sense_or_field !== "field") {
          return false;
        } else {
          return g_layerCheckList[d.layerID - 1];
        }
      });
      entries = _.countBy(data_select, function(d) {
        return Math.floor((d.tens - xmin) / xstep);
      });
      bindatum = _.map(xdomain, function(e, i) {
        return {
          itens: xdomain[i],
          ents: entries[i] != null ? entries[i] : 0
        };
      });
      ydomain = [
        0, d3.max(bindatum, function(d) {
          return d.ents;
        })
      ];
      if (this.first_call_hist[sense_or_field]) {
        d3.select("#menu_tension").append("div").attr("id", "menu_tension_" + sense_or_field);
        this.svg_tension_hist[sense_or_field] = append_svg("#menu_tension_" + sense_or_field);
        this.first_call_hist[sense_or_field] = false;
      }
      this.frame_tension_hist[sense_or_field] = make_frame(this.svg_tension_hist[sense_or_field], "tension (g)", "#/g", xdomain, ydomain, {
        xaxis_type: "roundBands",
        xaxis_tickValues: xaxis_tickValues
      });
      makeBarChart(this.frame_tension_hist[sense_or_field], bindatum, "itens", "ents", (function() {
        if (sense_or_field === "sense") {
          return "#ed5454";
        } else {
          return "#3874e3";
        }
      }), {
        label: [
          {
            data: ["ents"]
          }
        ]
      });
      tension_mean = _.reduce(data_select, (function(memo, d) {
        return memo + parseFloat(d.tens);
      }), 0) / data_select.length;
      tension_rms = _.reduce(data_select, (function(memo, d) {
        return memo + Math.pow(parseFloat(d.tens) - tension_mean, 2);
      }), 0) / data_select.length;
      tension_rms = Math.sqrt(tension_rms);
      frac_rms = (tension_rms / tension_mean * 100).toFixed(0);
      makeStatBox(this.frame_tension_hist[sense_or_field], w - 250, 20, "Mean " + (tension_mean.toFixed(2)) + " g");
      return makeStatBox(this.frame_tension_hist[sense_or_field], w - 250, 40, "Rms " + (tension_rms.toFixed(2)) + " g (" + frac_rms + " %)");
    };

    return TensionHistogram;

  })();

  TempHumid = (function() {
    function TempHumid() {}

    TempHumid.plot = function(inside, outside) {
      var data, frame_humid, frame_temp, stroke, svg_humid, svg_temp, xdomain, ydomain_humid, ydomain_temp;
      data = inside.concat(outside);
      svg_temp = append_svg("#menu_temp");
      svg_humid = append_svg("#menu_temp");
      xdomain = d3.extent(data, function(d) {
        return d.utime;
      });
      ydomain_temp = d3.extent(data, function(d) {
        return d.temp;
      });
      ydomain_humid = d3.extent(data, function(d) {
        return d.humid;
      });
      frame_temp = make_frame(svg_temp, "date", "temperature (C)", xdomain, ydomain_temp, {
        xaxis_type: "time"
      });
      frame_humid = make_frame(svg_humid, "date", "humidity (%)", xdomain, ydomain_humid, {
        xaxis_type: "time"
      });
      stroke = {
        "in": "#ed5454",
        out: "#3874e3"
      };
      makeScatterPlot(frame_temp, data, "utime", "temp", {
        r: 1,
        fill: function(d) {
          return "none";
        },
        stroke: function(d) {
          return stroke[d.location];
        },
        stroke_width: "1px"
      }, [
        {
          label: "inside",
          stroke: '#ed5454',
          fill: "none",
          ypos: "66"
        }, {
          label: "outside",
          stroke: '#3874e3',
          fill: "none",
          ypos: "83"
        }
      ], {
        label: [
          {
            data: [
              "date", function(d) {
                return d.temp;
              }
            ],
            separator: ' ',
            postfix: ' C'
          }
        ]
      });
      return makeScatterPlot(frame_humid, data, "utime", "humid", {
        r: 1,
        fill: function(d) {
          return "none";
        },
        stroke: function(d) {
          return stroke[d.location];
        },
        stroke_width: "1px"
      }, [
        {
          label: "inside",
          stroke: '#ed5454',
          fill: "none",
          ypos: "66"
        }, {
          label: "outside",
          stroke: '#3874e3',
          fill: "none",
          ypos: "83"
        }
      ], {
        label: [
          {
            data: [
              "date", function(d) {
                return d.humid;
              }
            ],
            separator: ' ',
            postfix: ' %'
          }
        ]
      });
    };

    return TempHumid;

  })();

  $(function() {
    var onFileLoad, s3, spinner, today_date, today_dir;
    spinner = new Spinner(spin_opts).spin($("#status").get(0));
    s3 = new S3();
    $("#upload-xml #upload-form-file").change(function() {
      var file, reader;
      file = this.files[0];
      $(name + " #error").html("");
      $(name + " #error").hide();
      console.log("file.name -> ", file.name);
      if (file.name !== "COMETCDC.xml") {
        console.log("filename is incorrect");
        return;
      }
      reader = new FileReader();
      reader.onload = onFileLoad;
      reader.readAsText(file);
    });
    today_date = "2015/07/27";
    today_dir = "20150727";
    onFileLoad = function(e) {
      var current_dir, daily_data, daily_dir, parser, ref1, stats_dir, xmlDoc;
      parser = new DOMParser();
      xmlDoc = parser.parseFromString(e.target.result, "text/xml");
      ref1 = make_daily_data(xmlDoc), today_date = ref1[0], today_dir = ref1[1], daily_data = ref1[2];
      console.log("TODAY: " + today_date + " " + today_dir);
      daily_dir = "daily/" + today_dir;
      current_dir = "daily/current";
      stats_dir = "stats";
      s3.putObjectWithProgress(daily_dir + "/data.json", JSON.stringify(daily_data), "#upload-xml", "#upload-json-daily-data #progress_msg", "#upload-json-daily-data #progress_bar");
      s3.putObjectWithProgress(current_dir + "/data.json", JSON.stringify(daily_data), "#upload-xml", "#upload-json-current-data #progress_msg", "#upload-json-current-data #progress_bar");
      s3.getJSON_prev_stat(today_dir, function(prev_stat) {
        var daily_stat;
        daily_stat = make_stat(today_date, prev_stat, daily_data);
        s3.putObjectWithProgress(daily_dir + "/stat.json", JSON.stringify(daily_stat), "#upload-xml", "#upload-json-daily-stat #progress_msg", "#upload-json-daily-stat #progress_bar");
        s3.putObjectWithProgress(current_dir + "/stat.json", JSON.stringify(daily_stat), "#upload-xml", "#upload-json-current-stat #progress_msg", "#upload-json-current-stat #progress_bar");
        return s3.getJSON_stats(function(prev_stats) {
          var stats;
          if (_.last(prev_stats).date !== daily_stat.date) {
            if (prev_stats.date !== daily_stat.date) {
              stats = prev_stats.concat(daily_stat);
            }
            return s3.putObjectWithProgress(stats_dir + "/stats.json", JSON.stringify(stats), "#upload-xml", "#upload-json-stats #progress_msg", "#upload-json-stats #progress_bar");
          } else {
            return console.log("will not upload stats.json because stats = prev_stats.concat(daily_stat)");
          }
        });
      });
    };
    zipWrapper("#upload-xml #upload-form-file", function(blob) {
      console.log("starting ajax...");
      console.log("blog: " + blob);
      return s3.putObjectWithProgress("zip/" + today_dir + "/COMETCDC.zip", blob, "#upload-xml #upload-form-file", "#upload-xml #progress_msg", "#upload-xml #progress_bar");
    });
    s3.getObject("csv/dial_gauge.csv", function(url) {
      return d3.csv(url, function(error, csv) {
        return DialGauge.plot(csv);
      });
    });
    s3.getObject("stats/stats.json", function(url) {
      return d3.json(url, function(error, dailies) {
        Progress.plot(dailies);
        s3.getObject("csv/tension_bar.csv", function(url) {
          return d3.csv(url, function(error, csv) {
            return Loading.plot(csv, dailies);
          });
        });
        return s3.getObject("daily/current/data.json", function(url) {
          return d3.json(url, function(error, data) {
            Progress.plotLayerDays(data);
            spinner.stop();
            Endplate.plot(data, dailies[dailies.length - 1]);
            Tension.plot(data);
            TensionHistogram.plot(data, "sense");
            return TensionHistogram.plot(data, "field");
          });
        });
      });
    });
    return s3.getObject("csv/inside.json", function(url) {
      return d3.json(url, function(error, inside) {
        return s3.getObject("csv/outside.json", function(url) {
          return d3.json(url, function(error, outside) {
            return TempHumid.plot(inside, outside);
          });
        });
      });
    });
  });

}).call(this);
